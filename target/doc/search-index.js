var searchIndex = {};
searchIndex['petgraph'] = {"items":[[0,"","petgraph","**petgraph** is a graph data structure library.",null,null],[3,"MinScored","","**MinScored\\<K, T\\>** holds a score **K** and a scored object **T** in\na pair for use with a **BinaryHeap**.",null,null],[3,"Directed","","Marker type for a directed graph.",null,null],[3,"Undirected","","Marker type for an undirected graph.",null,null],[3,"Ptr","","A reference that is hashed and compared by its pointer value.",null,null],[4,"EdgeDirection","","Edge direction",null,null],[13,"Outgoing","","A **Outgoing** edge is an outward edge *from* the current node.",0,null],[13,"Incoming","","An **Incoming** edge is an inbound edge *to* the current node.",0,null],[11,"fmt","","",1,{"inputs":[{"name":"minscored"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"minscored"}],"output":{"name":"minscored"}}],[11,"eq","","",1,{"inputs":[{"name":"minscored"},{"name":"minscored"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"minscored"},{"name":"minscored"}],"output":{"name":"option"}}],[11,"cmp","","",1,{"inputs":[{"name":"minscored"},{"name":"minscored"}],"output":{"name":"ordering"}}],[0,"algo","","Graph algorithms.",null,null],[5,"is_isomorphic","petgraph::algo","Return **true** if the graphs **g0** and **g1** are isomorphic.",null,{"inputs":[{"name":"graph"},{"name":"graph"}],"output":{"name":"bool"}}],[5,"dijkstra","","Dijkstra's shortest path algorithm.",null,{"inputs":[{"name":"g"},{"name":"nodeid"},{"name":"option"},{"name":"f"}],"output":{"name":"hashmap"}}],[5,"is_cyclic_undirected","","Return **true** if the input graph contains a cycle.",null,{"inputs":[{"name":"graph"}],"output":{"name":"bool"}}],[5,"is_cyclic","","**Deprecated: Renamed to *is_cyclic_undirected*.**",null,{"inputs":[{"name":"graph"}],"output":{"name":"bool"}}],[5,"is_cyclic_directed","","Check if a directed graph contains cycles.",null,{"inputs":[{"name":"graph"}],"output":{"name":"bool"}}],[5,"toposort","","Perform a topological sort of a directed graph.",null,{"inputs":[{"name":"graph"}],"output":{"name":"vec"}}],[5,"scc","","Compute *Strongly connected components* using Kosaraju's algorithm.",null,{"inputs":[{"name":"graph"}],"output":{"name":"vec"}}],[5,"connected_components","","Return the number of connected components of the graph.",null,{"inputs":[{"name":"graph"}],"output":{"name":"usize"}}],[5,"min_spanning_tree","","Return a *Minimum Spanning Tree* of a graph.",null,{"inputs":[{"name":"graph"}],"output":{"name":"graph"}}],[0,"graphmap","petgraph","**GraphMap\\<N, E\\>** is an undirected graph where node values are mapping keys.",null,null],[3,"GraphMap","petgraph::graphmap","**GraphMap\\<N, E\\>** is an undirected graph, with generic node values **N** and edge weights **E**.",null,null],[3,"Nodes","","",null,null],[3,"Neighbors","","",null,null],[3,"Edges","","",null,null],[12,"from","","",2,null],[12,"edges","","",2,null],[12,"iter","","",2,null],[8,"NodeTrait","","A trait group for **GraphMap**'s node identifier.",null,null],[11,"clone","","",3,{"inputs":[{"name":"graphmap"}],"output":{"name":"graphmap"}}],[11,"fmt","","",3,{"inputs":[{"name":"graphmap"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new **GraphMap**.",3,{"inputs":[{"name":"graphmap"}],"output":{"name":"graphmap"}}],[11,"with_capacity","","Create a new **GraphMap** with estimated capacity.",3,{"inputs":[{"name":"graphmap"},{"name":"usize"},{"name":"usize"}],"output":{"name":"graphmap"}}],[11,"node_count","","Return the number of nodes in the graph.",3,{"inputs":[{"name":"graphmap"}],"output":{"name":"usize"}}],[11,"edge_count","","Return the number of edges in the graph.",3,{"inputs":[{"name":"graphmap"}],"output":{"name":"usize"}}],[11,"clear","","Remove all nodes and edges",3,{"inputs":[{"name":"graphmap"}],"output":null}],[11,"add_node","","Add node **n** to the graph.",3,{"inputs":[{"name":"graphmap"},{"name":"n"}],"output":{"name":"n"}}],[11,"remove_node","","Return **true** if node **n** was removed.",3,{"inputs":[{"name":"graphmap"},{"name":"n"}],"output":{"name":"bool"}}],[11,"contains_node","","Return **true** if the node is contained in the graph.",3,{"inputs":[{"name":"graphmap"},{"name":"n"}],"output":{"name":"bool"}}],[11,"add_edge","","Add an edge connecting **a** and **b** to the graph.",3,{"inputs":[{"name":"graphmap"},{"name":"n"},{"name":"n"},{"name":"e"}],"output":{"name":"bool"}}],[11,"remove_edge","","Remove edge from **a** to **b** from the graph and return the edge weight.",3,{"inputs":[{"name":"graphmap"},{"name":"n"},{"name":"n"}],"output":{"name":"option"}}],[11,"contains_edge","","Return **true** if the edge connecting **a** with **b** is contained in the graph.",3,{"inputs":[{"name":"graphmap"},{"name":"n"},{"name":"n"}],"output":{"name":"bool"}}],[11,"nodes","","Return an iterator over the nodes of the graph.",3,{"inputs":[{"name":"graphmap"}],"output":{"name":"nodes"}}],[11,"neighbors","","Return an iterator over the nodes that are connected with **from** by edges.",3,{"inputs":[{"name":"graphmap"},{"name":"n"}],"output":{"name":"neighbors"}}],[11,"edges","","Return an iterator over the nodes that are connected with **from** by edges,\npaired with the edge weight.",3,{"inputs":[{"name":"graphmap"},{"name":"n"}],"output":{"name":"edges"}}],[11,"edge_weight","","Return a reference to the edge weight connecting **a** with **b**, or\n**None** if the edge does not exist in the graph.",3,{"inputs":[{"name":"graphmap"},{"name":"n"},{"name":"n"}],"output":{"name":"option"}}],[11,"edge_weight_mut","","Return a mutable reference to the edge weight connecting **a** with **b**, or\n**None** if the edge does not exist in the graph.",3,{"inputs":[{"name":"graphmap"},{"name":"n"},{"name":"n"}],"output":{"name":"option"}}],[6,"Item","","",null,null],[11,"next","","",4,{"inputs":[{"name":"nodes"}],"output":{"name":"option"}}],[11,"size_hint","","",4,null],[6,"Item","","",null,null],[11,"next","","",5,{"inputs":[{"name":"neighbors"}],"output":{"name":"option"}}],[11,"size_hint","","",5,null],[6,"Item","","",null,null],[11,"next","","",2,{"inputs":[{"name":"edges"}],"output":{"name":"option"}}],[6,"Output","","",null,null],[11,"index","","Index **GraphMap** by node pairs to access edge weights.",3,null],[11,"index_mut","","Index **GraphMap** by node pairs to access edge weights.",3,null],[0,"graph","petgraph","**Graph\\<N, E, Ty, Ix\\>** is a graph datastructure using an adjacency list representation.",null,null],[3,"NodeIndex","petgraph::graph","Node identifier.",null,null],[3,"EdgeIndex","","Edge identifier.",null,null],[3,"Node","","The graph's node type.",null,null],[12,"weight","","Associated node data.",6,null],[3,"Edge","","The graph's edge type.",null,null],[12,"weight","","Associated edge data.",7,null],[3,"Graph","","**Graph\\<N, E, Ty, Ix\\>** is a graph datastructure using an adjacency list representation.",null,null],[3,"WithoutEdges","","An iterator over either the nodes without edges to them or from them.",null,null],[3,"Neighbors","","Iterator over the neighbors of a node.",null,null],[3,"Edges","","Iterator over the edges of a node.",null,null],[6,"DefIndex","","The default integer type for node and edge indices in **Graph**.\n**u32** is the default to reduce the size of the graph's data and improve\nperformance in the common case.",null,null],[8,"IndexType","","Trait for the unsigned integer type used for node and edge indices.",null,null],[10,"new","","",8,{"inputs":[{"name":"indextype"},{"name":"usize"}],"output":{"name":"self"}}],[10,"index","","",8,{"inputs":[{"name":"indextype"}],"output":{"name":"usize"}}],[10,"max","","",8,{"inputs":[{"name":"indextype"}],"output":{"name":"self"}}],[11,"hash","","",9,null],[11,"cmp","","",9,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",9,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"option"}}],[11,"lt","","",9,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"le","","",9,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"gt","","",9,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"ge","","",9,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"eq","","",9,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"ne","","",9,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"fmt","","",9,{"inputs":[{"name":"nodeindex"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",9,{"inputs":[{"name":"nodeindex"}],"output":{"name":"nodeindex"}}],[11,"new","","",9,{"inputs":[{"name":"nodeindex"},{"name":"usize"}],"output":{"name":"nodeindex"}}],[11,"index","","",9,{"inputs":[{"name":"nodeindex"}],"output":{"name":"usize"}}],[11,"end","","",9,{"inputs":[{"name":"nodeindex"}],"output":{"name":"nodeindex"}}],[11,"hash","","",10,null],[11,"cmp","","",10,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",10,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"option"}}],[11,"lt","","",10,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"bool"}}],[11,"le","","",10,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"bool"}}],[11,"gt","","",10,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"bool"}}],[11,"ge","","",10,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"bool"}}],[11,"eq","","",10,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"bool"}}],[11,"clone","","",10,{"inputs":[{"name":"edgeindex"}],"output":{"name":"edgeindex"}}],[11,"new","","",10,{"inputs":[{"name":"edgeindex"},{"name":"usize"}],"output":{"name":"edgeindex"}}],[11,"index","","",10,{"inputs":[{"name":"edgeindex"}],"output":{"name":"usize"}}],[11,"end","","An invalid **EdgeIndex** used to denote absence of an edge, for example\nto end an adjacency list.",10,{"inputs":[{"name":"edgeindex"}],"output":{"name":"edgeindex"}}],[11,"fmt","","",10,{"inputs":[{"name":"edgeindex"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",6,{"inputs":[{"name":"node"}],"output":{"name":"node"}}],[11,"fmt","","",6,{"inputs":[{"name":"node"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"next_edge","","Accessor for data structure internals: the first edge in the given direction.",6,{"inputs":[{"name":"node"},{"name":"edgedirection"}],"output":{"name":"edgeindex"}}],[11,"clone","","",7,{"inputs":[{"name":"edge"}],"output":{"name":"edge"}}],[11,"fmt","","",7,{"inputs":[{"name":"edge"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"next_edge","","Accessor for data structure internals: the next edge for the given direction.",7,{"inputs":[{"name":"edge"},{"name":"edgedirection"}],"output":{"name":"edgeindex"}}],[11,"source","","Return the source node index.",7,{"inputs":[{"name":"edge"}],"output":{"name":"nodeindex"}}],[11,"target","","Return the target node index.",7,{"inputs":[{"name":"edge"}],"output":{"name":"nodeindex"}}],[11,"clone","","",11,{"inputs":[{"name":"graph"}],"output":{"name":"graph"}}],[11,"fmt","","",11,{"inputs":[{"name":"graph"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new **Graph** with directed edges.",11,{"inputs":[{"name":"graph"}],"output":{"name":"graph"}}],[11,"new_undirected","","Create a new **Graph** with undirected edges.",11,{"inputs":[{"name":"graph"}],"output":{"name":"graph"}}],[11,"with_capacity","","Create a new **Graph** with estimated capacity.",11,{"inputs":[{"name":"graph"},{"name":"usize"},{"name":"usize"}],"output":{"name":"graph"}}],[11,"node_count","","Return the number of nodes (vertices) in the graph.",11,{"inputs":[{"name":"graph"}],"output":{"name":"usize"}}],[11,"edge_count","","Return the number of edges in the graph.",11,{"inputs":[{"name":"graph"}],"output":{"name":"usize"}}],[11,"clear","","Remove all nodes and edges",11,{"inputs":[{"name":"graph"}],"output":null}],[11,"is_directed","","Return whether the graph has directed edges or not.",11,{"inputs":[{"name":"graph"}],"output":{"name":"bool"}}],[11,"into_edge_type","","Cast the graph as either undirected or directed. No edge adjustments\nare done.",11,{"inputs":[{"name":"graph"}],"output":{"name":"graph"}}],[11,"add_node","","Add a node (also called vertex) with weight **w** to the graph.",11,{"inputs":[{"name":"graph"},{"name":"n"}],"output":{"name":"nodeindex"}}],[11,"node_weight","","Access node weight for node **a**.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"option"}}],[11,"node_weight_mut","","Access node weight for node **a**.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"option"}}],[11,"neighbors","","Return an iterator of all nodes with an edge starting from **a**.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"neighbors"}}],[11,"neighbors_directed","","Return an iterator of all neighbors that have an edge between them and **a**,\nin the specified direction.\nIf the graph is undirected, this is equivalent to *.neighbors(a)*.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"edgedirection"}],"output":{"name":"neighbors"}}],[11,"neighbors_undirected","","Return an iterator of all neighbors that have an edge between them and **a**,\nin either direction.\nIf the graph is undirected, this is equivalent to *.neighbors(a)*.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"neighbors"}}],[11,"edges","","Return an iterator over the neighbors of node **a**, paired with their respective edge\nweights.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"edges"}}],[11,"edges_both","","Return an iterator over the edgs from **a** to its neighbors, then *to* **a** from its\nneighbors.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"edges"}}],[11,"add_edge","","Add an edge from **a** to **b** to the graph, with its edge weight.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"nodeindex"},{"name":"e"}],"output":{"name":"edgeindex"}}],[11,"update_edge","","Add or update an edge from **a** to **b**.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"nodeindex"},{"name":"e"}],"output":{"name":"edgeindex"}}],[11,"edge_weight","","Access the edge weight for **e**.",11,{"inputs":[{"name":"graph"},{"name":"edgeindex"}],"output":{"name":"option"}}],[11,"edge_weight_mut","","Access the edge weight for **e** mutably.",11,{"inputs":[{"name":"graph"},{"name":"edgeindex"}],"output":{"name":"option"}}],[11,"remove_node","","Remove **a** from the graph if it exists, and return its weight.\nIf it doesn't exist in the graph, return **None**.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"option"}}],[11,"remove_edge","","Remove an edge and return its edge weight, or **None** if it didn't exist.",11,{"inputs":[{"name":"graph"},{"name":"edgeindex"}],"output":{"name":"option"}}],[11,"find_edge","","Lookup an edge from **a** to **b**.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"option"}}],[11,"find_edge_undirected","","Lookup an edge between **a** and **b**, in either direction.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"option"}}],[11,"reverse","","Reverse the direction of all edges",11,{"inputs":[{"name":"graph"}],"output":null}],[11,"raw_nodes","","Access the internal node array",11,null],[11,"raw_edges","","Access the internal edge array",11,null],[11,"first_edge","","Accessor for data structure internals: the first edge in the given direction.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"edgedirection"}],"output":{"name":"option"}}],[11,"next_edge","","Accessor for data structure internals: the next edge for the given direction.",11,{"inputs":[{"name":"graph"},{"name":"edgeindex"},{"name":"edgedirection"}],"output":{"name":"option"}}],[11,"without_edges","","Return an iterator over either the nodes without edges to them or from them.",11,{"inputs":[{"name":"graph"},{"name":"edgedirection"}],"output":{"name":"withoutedges"}}],[6,"Item","","",null,null],[11,"next","","",12,{"inputs":[{"name":"withoutedges"}],"output":{"name":"option"}}],[6,"Item","","",null,null],[11,"next","","",13,{"inputs":[{"name":"neighbors"}],"output":{"name":"option"}}],[6,"Item","","",null,null],[11,"next","","",14,{"inputs":[{"name":"edges"}],"output":{"name":"option"}}],[6,"Output","","",null,null],[11,"index","","Index the **Graph** by **NodeIndex** to access node weights.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"n"}}],[11,"index_mut","","Index the **Graph** by **NodeIndex** to access node weights.",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"n"}}],[6,"Output","","",null,null],[11,"index","","Index the **Graph** by **EdgeIndex** to access edge weights.",11,{"inputs":[{"name":"graph"},{"name":"edgeindex"}],"output":{"name":"e"}}],[11,"index_mut","","Index the **Graph** by **EdgeIndex** to access edge weights.",11,{"inputs":[{"name":"graph"},{"name":"edgeindex"}],"output":{"name":"e"}}],[0,"visit","petgraph","Graph visitor algorithms.",null,null],[3,"AsUndirected","petgraph::visit","Wrapper type for walking the graph as if it is undirected",null,null],[3,"Reversed","","Wrapper type for walking edges the other way",null,null],[3,"Dfs","","A depth first search (DFS) of a graph.",null,null],[12,"stack","","",15,null],[12,"discovered","","",15,null],[3,"Bfs","","A breadth first search (BFS) of a graph.",null,null],[12,"stack","","",16,null],[12,"discovered","","",16,null],[8,"Graphlike","","",null,null],[16,"NodeId","petgraph::visit::Graphlike","",null,null],[8,"NeighborIter","petgraph::visit","A graph trait for accessing the neighbors iterator",null,null],[16,"Iter","petgraph::visit::NeighborIter","",null,null],[10,"neighbors","petgraph::visit","",17,{"inputs":[{"name":"neighboriter"},{"name":"nodeid"}],"output":{"name":"iter"}}],[8,"VisitMap","","",null,null],[10,"visit","","Return **true** if the value is not already present.",18,{"inputs":[{"name":"visitmap"},{"name":"n"}],"output":{"name":"bool"}}],[10,"is_visited","","",18,{"inputs":[{"name":"visitmap"},{"name":"n"}],"output":{"name":"bool"}}],[8,"Visitable","","Trait for GraphMap that knows which datastructure is the best for its visitor map",null,null],[16,"Map","petgraph::visit::Visitable","",null,null],[10,"visit_map","petgraph::visit","",19,{"inputs":[{"name":"visitable"}],"output":{"name":"map"}}],[8,"GetAdjacencyMatrix","","Create or access the adjacency matrix of a graph",null,null],[16,"AdjMatrix","petgraph::visit::GetAdjacencyMatrix","",null,null],[10,"adjacency_matrix","petgraph::visit","",20,{"inputs":[{"name":"getadjacencymatrix"}],"output":{"name":"adjmatrix"}}],[10,"is_adjacent","","",20,{"inputs":[{"name":"getadjacencymatrix"},{"name":"adjmatrix"},{"name":"nodeid"},{"name":"nodeid"}],"output":{"name":"bool"}}],[6,"Iter","","",null,null],[11,"neighbors","petgraph::graph","",11,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"neighbors"}}],[6,"Iter","petgraph::visit","",null,null],[11,"neighbors","petgraph::graphmap","",3,{"inputs":[{"name":"graphmap"},{"name":"n"}],"output":{"name":"neighbors"}}],[6,"Iter","petgraph::visit","",null,null],[11,"neighbors","","",21,{"inputs":[{"name":"asundirected"},{"name":"nodeindex"}],"output":{"name":"neighbors"}}],[6,"Iter","","",null,null],[11,"neighbors","","",22,{"inputs":[{"name":"reversed"},{"name":"nodeindex"}],"output":{"name":"neighbors"}}],[11,"visit","collections::bit","",23,{"inputs":[{"name":"bitset"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"is_visited","","",23,{"inputs":[{"name":"bitset"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"visit","std::collections::hash::set","",24,{"inputs":[{"name":"hashset"},{"name":"n"}],"output":{"name":"bool"}}],[11,"is_visited","","",24,{"inputs":[{"name":"hashset"},{"name":"n"}],"output":{"name":"bool"}}],[6,"NodeId","petgraph::visit","",null,null],[6,"Map","","",null,null],[11,"visit_map","petgraph::graph","",11,{"inputs":[{"name":"graph"}],"output":{"name":"bitset"}}],[6,"NodeId","petgraph::visit","",null,null],[6,"Map","","",null,null],[11,"visit_map","petgraph::graphmap","",3,{"inputs":[{"name":"graphmap"}],"output":{"name":"hashset"}}],[6,"NodeId","petgraph::visit","",null,null],[6,"NodeId","","",null,null],[6,"Map","","",null,null],[11,"visit_map","","",21,null],[6,"Map","","",null,null],[11,"visit_map","","",22,null],[6,"AdjMatrix","","",null,null],[11,"adjacency_matrix","petgraph::graphmap","",3,{"inputs":[{"name":"graphmap"}],"output":null}],[11,"is_adjacent","","",3,null],[11,"fmt","petgraph::visit","",15,{"inputs":[{"name":"dfs"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",15,{"inputs":[{"name":"dfs"}],"output":{"name":"dfs"}}],[11,"new","","Create a new **Dfs**, using the graph's visitor map, and put **start**\nin the stack of nodes to visit.",15,{"inputs":[{"name":"dfs"},{"name":"g"},{"name":"nodeid"}],"output":{"name":"dfs"}}],[11,"empty","","Create a new **Dfs** using the graph's visitor map, and no stack.",15,{"inputs":[{"name":"dfs"},{"name":"g"}],"output":{"name":"dfs"}}],[11,"move_to","","Keep the discovered map, but clear the visit stack and restart\nthe dfs from a particular node.",15,{"inputs":[{"name":"dfs"},{"name":"n"}],"output":null}],[11,"next","","Return the next node in the dfs, or **None** if the traversal is done.",15,{"inputs":[{"name":"dfs"},{"name":"g"}],"output":{"name":"option"}}],[11,"clone","","",16,{"inputs":[{"name":"bfs"}],"output":{"name":"bfs"}}],[11,"new","","Create a new **Bfs**, using the graph's visitor map, and put **start**\nin the stack of nodes to visit.",16,{"inputs":[{"name":"bfs"},{"name":"g"},{"name":"nodeid"}],"output":{"name":"bfs"}}],[11,"next","","Return the next node in the dfs, or **None** if the traversal is done.",16,{"inputs":[{"name":"bfs"},{"name":"g"}],"output":{"name":"option"}}],[0,"unionfind","petgraph","**UnionFind\\<K\\>** is a disjoint-set data structure.",null,null],[3,"UnionFind","petgraph::unionfind","**UnionFind\\<K\\>** is a disjoint-set data structure. It tracks set membership of *n* elements\nindexed from *0* to *n - 1*. The scalar type is **K** which must be an unsigned integer type.",null,null],[11,"clone","","",25,{"inputs":[{"name":"unionfind"}],"output":{"name":"unionfind"}}],[11,"fmt","","",25,{"inputs":[{"name":"unionfind"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new **UnionFind** of **n** disjoint sets.",25,{"inputs":[{"name":"unionfind"},{"name":"usize"}],"output":{"name":"unionfind"}}],[11,"find","","Return the representative for **x**.",25,{"inputs":[{"name":"unionfind"},{"name":"k"}],"output":{"name":"k"}}],[11,"find_mut","","Return the representative for **x**.",25,{"inputs":[{"name":"unionfind"},{"name":"k"}],"output":{"name":"k"}}],[11,"union","","Unify the two sets containing **x** and **y**.",25,{"inputs":[{"name":"unionfind"},{"name":"k"},{"name":"k"}],"output":{"name":"bool"}}],[11,"into_labeling","","Return a vector mapping each element to its representative.",25,{"inputs":[{"name":"unionfind"}],"output":{"name":"vec"}}],[11,"adjacency_matrix","petgraph::graph","",11,{"inputs":[{"name":"graph"}],"output":{"name":"bitvec"}}],[11,"is_adjacent","","",11,{"inputs":[{"name":"graph"},{"name":"bitvec"},{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[8,"EdgeType","petgraph","A graph's edge type determines whether is has directed edges or not.",null,null],[10,"is_directed","","",26,{"inputs":[{"name":"edgetype"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"edgedirection"},{"name":"edgedirection"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"edgedirection"},{"name":"edgedirection"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"edgedirection"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"edgedirection"}],"output":{"name":"edgedirection"}}],[11,"fmt","","",27,{"inputs":[{"name":"directed"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",27,{"inputs":[{"name":"directed"}],"output":{"name":"directed"}}],[11,"fmt","","",28,{"inputs":[{"name":"undirected"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",28,{"inputs":[{"name":"undirected"}],"output":{"name":"undirected"}}],[11,"is_directed","","",27,{"inputs":[{"name":"directed"}],"output":{"name":"bool"}}],[11,"is_directed","","",28,{"inputs":[{"name":"undirected"}],"output":{"name":"bool"}}],[11,"clone","","",29,{"inputs":[{"name":"ptr"}],"output":{"name":"ptr"}}],[11,"eq","","Ptr compares by pointer equality, i.e if they point to the same value",29,{"inputs":[{"name":"ptr"},{"name":"ptr"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",29,{"inputs":[{"name":"ptr"},{"name":"ptr"}],"output":{"name":"option"}}],[11,"cmp","","Ptr is ordered by pointer value, i.e. an arbitrary but stable and total order.",29,{"inputs":[{"name":"ptr"},{"name":"ptr"}],"output":{"name":"ordering"}}],[6,"Target","","",null,null],[11,"deref","","",29,{"inputs":[{"name":"ptr"}],"output":{"name":"t"}}],[11,"hash","","",29,{"inputs":[{"name":"ptr"},{"name":"h"}],"output":null}],[11,"fmt","","",29,{"inputs":[{"name":"ptr"},{"name":"formatter"}],"output":{"name":"result"}}]],"paths":[[4,"EdgeDirection"],[3,"MinScored"],[3,"Edges"],[3,"GraphMap"],[3,"Nodes"],[3,"Neighbors"],[3,"Node"],[3,"Edge"],[8,"IndexType"],[3,"NodeIndex"],[3,"EdgeIndex"],[3,"Graph"],[3,"WithoutEdges"],[3,"Neighbors"],[3,"Edges"],[3,"Dfs"],[3,"Bfs"],[8,"NeighborIter"],[8,"VisitMap"],[8,"Visitable"],[8,"GetAdjacencyMatrix"],[3,"AsUndirected"],[3,"Reversed"],[3,"BitSet"],[3,"HashSet"],[3,"UnionFind"],[8,"EdgeType"],[3,"Directed"],[3,"Undirected"],[3,"Ptr"]]};
initSearch(searchIndex);
